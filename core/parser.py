"""
The parser pakes the list of tokens generated by the lexer 
and forms relationships between them by building the abstract syntax tree.
To read more about each function and their relationships, refer to the parser document.
 """
from typing import Optional
from core.data.token_types import *
from core.data.nodes import *
from core.util.symbol_table import SymbolTable, SymbolEntry, global_table, GlobalEntry
from core.util.error import error

class Parser:
    def __init__(self, tokens: list):
        self.tokens = tokens
        self.pos = 0
        self.table_stack = []
        self.keywords = {
            TokenType.INT, TokenType.FLOAT,
            TokenType.CHAR, TokenType.VOID
        }
    
    # Returns the next token to be parsed
    def peek(self) -> Optional[Token]:
        if self.pos < len(self.tokens):
            return self.tokens[self.pos]
        error.report(error_msg="Incomplete code", line=self.tokens[-1].line, type="Syntax")
        error.display("Parsing")
    
    # Returns token if the expected token is the next one
    def consume(self, *expected_type: TokenType) -> Token:
        for e in expected_type:
            tok = self.peek()
            if tok.type == e:
                self.pos += 1
                return tok
        error.report(
            error_msg=f"Expected {[t.name for t in expected_type]}, got '{tok.type.name}'",
            line=tok.line, type="SyntaxError"
            )
        error.display("Parsing")

    def search_blocks(self, id: str) -> bool:
        i = -1
        while -i <= len(self.table_stack):
            symbol = self.table_stack[i]
            if id in symbol.table:
                return symbol.get(id)
            else:
                i -= 1
        if id in global_table and isinstance(global_table[id], GlobalEntry):
            return global_table[id]
        return None

    def next_is_block(self):
        return self.peek().type == TokenType.OPEN_BRACE

    def remove_declare(self, init_set, uninits):
        trimmed = []
        for u in uninits:
            if u.id.id not in init_set:
                trimmed.append(u)
        return trimmed
    # TODO: remove uninits
    
    # Builds AST from the program node down
    def parse_program(self) -> Program:
        inits = []
        uninits = []
        funcs = []
        init_set = set()
        while self.pos < len(self.tokens):
            top = self.parse_global()
            if isinstance(top, Function):
                funcs.append(top)
            elif isinstance(top, GlobalVar):
                if top.init:
                    init_set.add(top.id.id)
                    inits.append(top)
                else:
                    uninits.append(top)
            uninits = self.remove_declare(init_set, uninits)
        return Program(init_vars=inits, uninit_vars=uninits, funcs=funcs)

    def parse_global(self) -> Top:
        _type = self.consume(
            TokenType.INT, TokenType.FLOAT,
            TokenType.CHAR, TokenType.VOID
            )
        name = self.consume(TokenType.ID)
        if self.peek().type == TokenType.ASSIGNMENT or self.peek().type == TokenType.SEMICOLON:
            return self.parse_global_var(_type=_type, id=name)
        else:
            return self.parse_function(return_type=_type, name=name)

    def parse_global_var(self, _type: TokenType, id: TokenType) -> Top:
        val = 0
        init = False
        if self.peek().type == TokenType.ASSIGNMENT:
            init = True
            self.consume(TokenType.ASSIGNMENT)
            val = self.parse_assignment()
        entry = GlobalEntry(id=id.value, type=_type.type, initialised=init, line=id.line)
        variable = Var(id=id.value, line=id.line, type=_type.type)

        if id.value in global_table:
            if not isinstance(global_table[id.value], GlobalEntry):
                error.report(
                    error_msg=f"Cannot declare global variable '{id.value}', a function has that name already",
                    line=id.line, type="SyntaxError"
                )
            elif global_table[id.value].initialised and init == True:
                error.report(
                    error_msg=f"Global variable '{id.value}' already declared and initialised",
                    line=id.line, type="SyntaxError"
                )
            elif not global_table[id.value].initialised and init == True:
                global_table[id.value].initialised == True
                global_table[id.value].exp = val
        else:
            global_table[id.value] = entry
        self.consume(TokenType.SEMICOLON)
        error.display("Parsing")
        return GlobalVar(id=variable, type=_type.type, exp=val, line=id.line, init=init)
    
    def parse_function(self, return_type: TokenType, name: TokenType) -> Top:
        self.consume(TokenType.OPEN_PARENTHESIS)
        args = []
        param_set = set()
        while self.peek().type in self.keywords:
            arg_name = None
            _type = self.consume(
                TokenType.INT, TokenType.FLOAT,
                TokenType.CHAR, TokenType.VOID
                )
            if _type.type == TokenType.VOID:
                break
            if self.peek().type == TokenType.ID:
                arg_name = self.consume(TokenType.ID)
                if arg_name.value in param_set:
                    error.report(
                        error_msg=f"Cannot have duplicate parameters '{arg_name.value}' in function '{name.value}'",
                        line=name.line, type="SyntaxError"
                        )
                param_set.add(arg_name.value)
            args.append((_type.type, arg_name.value) if arg_name else (_type.type, None))
            if self.peek().type == TokenType.COMMA:
                self.consume(TokenType.COMMA)
                if self.peek().type not in self.keywords:
                    error.report(error_msg=f"Misplaced comma in function {name.value}", line=name.line, type="SyntaxError")

        self.consume(TokenType.CLOSE_PARENTHESIS)
        if self.peek().type == TokenType.SEMICOLON:
            self.consume(TokenType.SEMICOLON)
            func = Function(name=name.value, variables=args, _return=return_type.type, prototype=True)
            if name.value in global_table:
                declared = global_table[name.value]
                if isinstance(declared, GlobalEntry):
                    error.report(
                        error_msg=f"Cannot declare function '{name.value}' a global variable already has that name",
                        line=name.line, type="SyntaxError"
                        )
                elif declared.prototype:
                    error.report(
                        error_msg="Cannot declare two functions of the same name",
                        line=name.line, type="SyntaxError"
                        )
                elif len(declared.variables) != len(func.variables):
                    error.report(
                        error_msg=f"Mismatch parameter count in function {name.value}",
                        line=name.line, type="SyntaxError"
                    )
            else:
                global_table[name.value] = func
            error.display("Parsing")
            return

        symbol = SymbolTable(fun_name=name.value, args=args, return_type=return_type.type)
        param_offset = 16
        for i in range(-1, -(len(args) + 1), -1):
            _type, arg_name = args[i]
            entry = SymbolEntry(id=arg_name, type=_type, initialised=True, line=name.line, offset=param_offset)
            symbol.insert(id=arg_name, entry=entry)
            param_offset += 8

        func = Function(
            name=name.value, variables=args,
            _return=return_type.type, prototype=False
            )
        if name.value in global_table:
            declared = global_table[name.value]
            if isinstance(declared, GlobalEntry):
                    error.report(
                        error_msg=f"Cannot declare function '{name.value}' a global variable already has that name",
                        line=name.line, type="SyntaxError"
                        )
            elif not declared.prototype:
                error.report(
                    error_msg="Cannot declare two functions of the same name",
                    line=name.line, type="SyntaxError"
                    )
            elif len(declared.variables) != len(func.variables):
                error.report(
                    error_msg=f"Mismatch parameter count in function {name.value}",
                    line=name.line, type="SyntaxError"
                )
        else:
            global_table[name.value] = func
        error.display("Parsing")

        block = self.parse_block(symbol)
        func.body = block
        return func

    def parse_block(self, global_table: SymbolTable = None) -> BlockItem:
        if not global_table:
            global_table = SymbolTable()
        self.table_stack.append(global_table)
        blk_itms = []
        self.consume(TokenType.OPEN_BRACE)
        while self.peek().type != TokenType.CLOSE_BRACE:
            if self.peek().type in self.keywords:
                blk_itms.append(self.parse_declare())
            elif self.next_is_block():
                blk_itms.append(self.parse_block())
            else:
                blk_itms.append(self.parse_statement())

        self.consume(TokenType.CLOSE_BRACE)
        self.table_stack.pop()
        return Block(block_items=blk_itms, symboltable=global_table)      

    def parse_statement(self) -> Statement:
        if self.peek().type == TokenType.RETURN:
            ret = self.parse_return()
            self.consume(TokenType.SEMICOLON)
            return ret
        elif self.peek().type == TokenType.IF:
            return self.parse_if()
        elif self.peek().type == TokenType.FOR:
            return self.parse_for()
        elif self.peek().type == TokenType.WHILE:
            return self.parse_while()
        elif self.peek().type == TokenType.DO:
            do_while = self.parse_do_while()
            self.consume(TokenType.SEMICOLON)
            return do_while
        elif self.peek().type == TokenType.BREAK:
            br = self.consume(TokenType.BREAK)
            self.consume(TokenType.SEMICOLON)
            return Break(line=br.line)
        elif self.peek().type == TokenType.CONTINUE:
            cn = self.consume(TokenType.CONTINUE)
            self.consume(TokenType.SEMICOLON)
            return Continue(line=cn.line)
        else:
            exp = self.parse_exp_statement()
            self.consume(TokenType.SEMICOLON)
            return exp

    def parse_declare(self) -> Declare:
        symbol = self.table_stack[-1]
        _type = self.consume(
                TokenType.INT, TokenType.FLOAT,
                TokenType.CHAR, TokenType.VOID
                )
        id = self.consume(TokenType.ID)
        if id.value in symbol.table:
            error.report(
                error_msg=f"Cannot declare variable of same name {id.value} again in same scope",
                line=id.line, type="SyntaxError"
            )
        val = None
        init = False
        if self.peek().type == TokenType.ASSIGNMENT:
            init = True
            self.consume(TokenType.ASSIGNMENT)
            val = self.parse_assignment()
        entry = SymbolEntry(id=id.value, type=_type.type, initialised=init, line=id.line)
        variable = Var(id=id.value, type=_type.type, line=id.line)
        symbol.insert(id.value, entry)
        self.consume(TokenType.SEMICOLON)
        return Declare(id=variable, type=_type.type, exp=val, line=id.line)

    def parse_return(self) -> Statement:
        ret = self.consume(TokenType.RETURN)
        if self.peek().type == TokenType.SEMICOLON:
            return Return(line=ret.line)
        else:
            exp = self.parse_assignment()
            return Return(exp=exp, line=ret.line)
        
    def parse_if(self):
        self.consume(TokenType.IF)
        self.consume(TokenType.OPEN_PARENTHESIS)
        cond = self.parse_assignment()
        self.consume(TokenType.CLOSE_PARENTHESIS)
        if self.next_is_block():
            if_stm = self.parse_block()
        else:
            if_stm = self.parse_statement()
        
        if self.peek().type != TokenType.ELSE:
            return If(condition=cond, if_statement=if_stm)
        self.consume(TokenType.ELSE)
        if self.peek().type == TokenType.IF:
            else_stm = self.parse_if()
        elif self.next_is_block():
            else_stm = self.parse_block()
        else:
            else_stm = self.parse_statement()
        return If(condition=cond, if_statement=if_stm, else_statement=else_stm)
    
    def parse_for(self) -> Statement:
        self.consume(TokenType.FOR)
        self.consume(TokenType.OPEN_PARENTHESIS)
        symbol = None
        if self.peek().type == TokenType.INT:
            symbol = SymbolTable()
            self.table_stack.append(symbol)
            init = self.parse_declare()
        else:
            init = self.parse_exp_statement()
            self.consume(TokenType.SEMICOLON)
        control = self.parse_exp_statement()
        self.consume(TokenType.SEMICOLON)
        if not control.exp:
            control = ExpStatement(line=control.line, exp=IntLiteral(value=1, line=control.line))
        post_exp = self.parse_exp_statement()
        self.consume(TokenType.CLOSE_PARENTHESIS)
        
        if self.next_is_block():
            stm = self.parse_block()
        else:
            stm = self.parse_statement()
        
        if isinstance(init, Declare):
            self.table_stack.pop()
        return For(initial=init, condition=control, post_exp=post_exp, statement=stm, symboltable=(symbol if symbol else None))

    def parse_while(self) -> Statement:
        self.consume(TokenType.WHILE)
        self.consume(TokenType.OPEN_PARENTHESIS)
        control = self.parse_assignment()
        self.consume(TokenType.CLOSE_PARENTHESIS)
        if self.next_is_block():
            stm = self.parse_block()
        else:
            stm = self.parse_statement()
        return While(condition=control, statement=stm)

    def parse_do_while(self) -> Statement:
        self.consume(TokenType.DO)
        if self.next_is_block():
            stm = self.parse_block()
        else:
            stm = self.parse_statement()
        self.consume(TokenType.WHILE)
        self.consume(TokenType.OPEN_PARENTHESIS)
        control = self.parse_assignment()
        self.consume(TokenType.CLOSE_PARENTHESIS)
        return DoWhile(statement=stm, condition=control)
        
    def parse_exp_statement(self) -> Statement:
        null_stm = self.peek()
        if self.peek().type == TokenType.SEMICOLON:
            return ExpStatement(line=null_stm.line)
        elif self.peek().type == TokenType.CLOSE_PARENTHESIS:
            return ExpStatement(line=null_stm.line)
        else:
            exp = self.parse_assignment()
            return ExpStatement(line=exp.line, exp=exp)
    
    def parse_comma_exp(self) -> Exp:
        exp = self.parse_assignment()
        while self.peek().type == TokenType.COMMA:
            self.consume(TokenType.COMMA)
            rhs_exp = self.parse_assignment()
            exp = CommaExp(lhs=exp, rhs=rhs_exp, line=exp.line)       
        return exp

    def parse_assignment(self) -> Exp:
        if self.peek().type != TokenType.ID:
            return self.parse_conditional()
        
        self.pos += 1
        if self.peek().type not in (
            TokenType.ASSIGNMENT, TokenType.ASSIGN_ADD, TokenType.ASSIGN_SUB, 
            TokenType.ASSIGN_MULT, TokenType.ASSIGN_DIV, TokenType.ASSIGN_MOD,
            TokenType.ASSIGN_BIT_AND, TokenType.ASSIGN_BIT_OR, TokenType.ASSIGN_BIT_XOR,
            TokenType.ASSIGN_LEFT_SHIFT, TokenType.ASSIGN_RIGHT_SHIFT
            ):
            self.pos -= 1
            return self.parse_conditional()
        self.pos -= 1
        var = self.consume(TokenType.ID)

        if not self.search_blocks(var.value):
            error.report(error_msg=f"Cannot assign a value to undeclared variable {var.value}", line=var.line, type="SyntaxError")
        
        symbol = self.table_stack[-1]
        if self.peek().type != TokenType.ASSIGNMENT and not symbol.get(var.value).initialised:
            error.report(
                error_msg=f"Cannot perform operation {self.peek().type.name} on uninitialised variable {var.value}",
                line=var.line, type="SyntaxError"
                )
        declared = symbol.get(var.value)
        _type = declared.type
        operation = self.consume(
            TokenType.ASSIGNMENT, TokenType.ASSIGN_ADD, TokenType.ASSIGN_SUB, 
            TokenType.ASSIGN_MULT, TokenType.ASSIGN_DIV, TokenType.ASSIGN_MOD,
            TokenType.ASSIGN_BIT_AND, TokenType.ASSIGN_BIT_OR, TokenType.ASSIGN_BIT_XOR,
            TokenType.ASSIGN_LEFT_SHIFT, TokenType.ASSIGN_RIGHT_SHIFT
            )
        if self.peek().type == TokenType.ID:
            assign = self.parse_assignment()
            if isinstance(assign, Assign):
                assign = assign.id  # Assign.id is a Var
        else:
            assign = self.parse_conditional()

        variable = Var(id=var.value, line=var.line, type=_type)

        if operation.type == TokenType.ASSIGN_ADD:
            assign = AddSub(operator=TokenType.ADDITION, operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_SUB:
            assign = AddSub(operator=TokenType.SUBTRACTION, operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_MULT:
            assign = MultDivMod(operator=TokenType.MULTIPLICATION, operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_DIV:
            assign = MultDivMod(operator=TokenType.DIVISION, operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_MOD:
            assign = MultDivMod(operator=TokenType.MODULO, operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_BIT_AND:
            assign = BitAND(operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_BIT_OR:
            assign = BitOR(operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_BIT_OR:
            assigne = BitXOR(operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_RIGHT_SHIFT:
            assign = BitShift(operator=TokenType.BIT_SHIFT_RIGHT, operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_LEFT_SHIFT:
            assign = BitShift(operator=TokenType.BIT_SHIFT_LEFT, operand1=variable, operand2=assign, line=var.line)

        return Assign(id=variable, exp=assign, line=var.line, type=_type)

    def parse_conditional(self) -> Exp:
        cond = self.parse_or()
        if self.peek().type != TokenType.QUESTION_MARK:
            return cond
        self.consume(TokenType.QUESTION_MARK)
        if_stm = self.parse_assignment()
        self.consume(TokenType.COLON)
        else_stm = self.parse_conditional()
        return Conditional(condition=cond, if_statement=if_stm, else_statement=else_stm, line=cond.line)

    def parse_or(self) -> Exp:
        exp = self.parse_and()
        while self.peek().type == TokenType.OR:
            self.pos += 1
            next_exp = self.parse_and()
            exp = OR(operand1=exp, operand2=next_exp, line=exp.line)
        return exp
    
    def parse_and(self) -> Exp:
        exp = self.parse_equality()
        while self.peek().type == TokenType.AND:
            self.pos += 1
            next_exp = self.parse_equality()
            exp = AND(operand1=exp, operand2=next_exp, line=exp.line)
        return exp

    def parse_equality(self) -> Exp:
        exp = self.parse_inequality()
        while self.peek().type == TokenType.EQUAL or self.peek().type == TokenType.NOT_EQUAL:
            op = self.consume(TokenType.EQUAL, TokenType.NOT_EQUAL)
            next_exp = self.parse_inequality()
            exp = Equality(operator=op.type, operand1=exp, operand2=next_exp, line=exp.line)
        return exp

    def parse_inequality(self) -> Exp:
        exp = self.parse_bit_or()
        while (self.peek().type == TokenType.LESS_THAN or self.peek().type == TokenType.LESS_THAN_OR_EQUAL
        or self.peek().type == TokenType.GREATER_THAN or self.peek().type == TokenType.GREATER_THAN_OR_EQUAL):
            op = self.consume(
                TokenType.LESS_THAN, TokenType.LESS_THAN_OR_EQUAL,
                TokenType.GREATER_THAN, TokenType.GREATER_THAN_OR_EQUAL
                )
            next_exp = self.parse_bit_or()
            exp = Inequality(operator=op.type, operand1=exp, operand2=next_exp, line=exp.line)
        return exp

    def parse_bit_or(self) -> Exp:
        exp = self.parse_bit_xor()
        while self.peek().type == TokenType.BIT_OR:
            self.pos += 1
            next_exp = self.parse_bit_xor()
            exp = BitOR(operand1=exp, operand2=next_exp, line=exp.line)
        return exp

    def parse_bit_xor(self) -> Exp:
        exp = self.parse_bit_and()
        while self.peek().type == TokenType.BIT_XOR:
            self.pos += 1
            next_exp = self.parse_bit_and()
            exp = BitXOR(operand1=exp, operand2=next_exp, line=exp.line)
        return exp
    
    def parse_bit_and(self) -> Exp:
        exp = self.parse_bit_shift()
        while self.peek().type == TokenType.BIT_AND:
            self.pos += 1
            next_exp = self.parse_bit_shift()
            exp = BitAND(operand1=exp, operand2=next_exp, line=exp.line)
        return exp

    def parse_bit_shift(self) -> Exp:
        exp = self.parse_addsub()
        while self.peek().type == TokenType.BIT_SHIFT_LEFT or self.peek().type == TokenType.BIT_SHIFT_RIGHT:
            op = self.consume(TokenType.BIT_SHIFT_LEFT, TokenType.BIT_SHIFT_RIGHT)
            shift_amount = self.parse_addsub()
            exp = BitShift(operator=op.type, value=exp, shift=shift_amount, line=exp.line)
        return exp

    def parse_addsub(self) -> Exp:
        term = self.parse_term()
        while self.peek().type == TokenType.ADDITION or self.peek().type == TokenType.SUBTRACTION:
            op = self.consume(TokenType.ADDITION, TokenType.SUBTRACTION)
            next_term = self.parse_term()
            term = AddSub(operator=op.type, operand1=term, operand2=next_term, line=term.line)
        return term
    
    def parse_term(self) -> Exp:
        fact = self.parse_fact()
        while (
            self.peek().type == TokenType.MULTIPLICATION
            or self.peek().type == TokenType.DIVISION
            or self.peek().type == TokenType.MODULO
            ):
            op = self.consume(TokenType.MULTIPLICATION, TokenType.DIVISION, TokenType.MODULO)
            next_fact = self.parse_fact()
            fact = MultDivMod(operator=op.type, operand1=fact, operand2=next_fact, line=fact.line)
        return fact
    

    def parse_fact(self) -> Exp:
        tok = self.consume(
            TokenType.OPEN_PARENTHESIS,
            TokenType.INT_LITERAL,
            TokenType.SUBTRACTION, 
            TokenType.BIT_COMP, 
            TokenType.LOGICAL_NEGATION,
            TokenType.ID, 
            TokenType.INCREMENT,
            TokenType.DECREMENT
        )
        if tok.type == TokenType.OPEN_PARENTHESIS:
            tok = self.parse_comma_exp()
            self.consume(TokenType.CLOSE_PARENTHESIS)
            return Parenthesis(exp=tok, line=tok.line)
        
        elif tok.type == TokenType.INT_LITERAL:
            return IntLiteral(value=int(tok.value), line=tok.line)
        
        elif (
            tok.type == TokenType.BIT_COMP or tok.type == TokenType.SUBTRACTION 
            or tok.type == TokenType.LOGICAL_NEGATION 
        ):
            inner_exp = self.parse_fact()
            return UnOp(operator=tok.type, operand=inner_exp, line=tok.line)

        elif tok.type == TokenType.INCREMENT or tok.type == TokenType.DECREMENT:
            id = self.consume(TokenType.ID)
            declared = self.search_blocks(tok.value)
            if not declared:
                error.report(error_msg=f"Variable {tok.value} not declared at this scope", line=tok.line, type="SyntaxError")
            _type = declared.type 
            if tok.type == TokenType.INCREMENT:
                return Increment(id=id.value, prefix=True, line=tok.line, type=_type)
            elif tok.type == TokenType.DECREMENT:
                return Decrement(id=id.value, prefix=True, line=tok.line, type=_type)

        
        elif tok.type == TokenType.ID:
            if self.peek().type == TokenType.OPEN_PARENTHESIS:
                return self.parse_func_call(tok)
            declared = self.search_blocks(tok.value)
            if not declared:
                error.report(error_msg=f"Variable {tok.value} not declared at this scope", line=tok.line, type="SyntaxError")
            _type = declared.type
            if self.peek().type == TokenType.INCREMENT:
                self.consume(TokenType.INCREMENT)
                return Increment(id=tok.value, prefix=False, line=tok.line, type=_type)
            elif self.peek().type == TokenType.DECREMENT:
                self.consume(TokenType.DECREMENT)
                return Decrement(id=tok.value, prefix=False, line=tok.line, type=_type)
                
            else:
                return Var(id=tok.value, line=tok.line, type=_type)

    def parse_func_call(self, name: Token):
        if name.value not in global_table:
            error.report(error_msg=f"Cannot call undeclared function {name.value}", line=name.line, type="SyntaxError")
            error.display("Parsing")
        self.consume(TokenType.OPEN_PARENTHESIS)
        params = []
        while self.peek().type != TokenType.CLOSE_PARENTHESIS:
            arg = self.parse_conditional()
            params.append(arg)
            if self.peek().type == TokenType.COMMA:
                self.consume(TokenType.COMMA)

        func = global_table[name.value] 
        if isinstance(func, GlobalEntry):
            error.report(error_msg=f"'{func.id}' is not a function", line=name.line, type="SyntaxError")  
        elif len(func.variables) != len(params):
            error.report(
                error_msg=f"Incorrect parameter count in calling function {name.value}",
                line=name.line, type="SyntanError"
            )
        self.consume(TokenType.CLOSE_PARENTHESIS)
        return FunctionCall(name=name.value, param=params, line=name.line)