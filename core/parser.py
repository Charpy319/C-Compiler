"""
The parser pakes the list of tokens generated by the lexer 
and forms relationships between them by building the abstract syntax tree.
To read more about each function and their relationships, refer to the parser document.
 """
from typing import Optional
from core.data.token_types import *
from core.data.nodes import *
from core.util.symbol_table import SymbolTable, SymbolEntry
from core.util.error import error

class Parser:
    def __init__(self, tokens: list):
        self.tokens = tokens
        self.pos = 0
        self.table_stack = []
        self.keywords = {
            TokenType.INT, TokenType.FLOAT,
            TokenType.CHAR, TokenType.VOID
        }
    
    # Returns the next token to be parsed
    def peek(self) -> Optional[Token]:
        if self.pos < len(self.tokens):
            return self.tokens[self.pos]
        error.report(error_msg="Incomplete code", line=self.tokens[-1].line, type="Syntax")
        error.display("Parsing")
    
    # Returns token if the expected token is the next one
    def consume(self, *expected_type: TokenType) -> Token:
        for e in expected_type:
            tok = self.peek()
            if tok.type == e:
                self.pos += 1
                return tok
        error.report(error_msg=f"Expected {[t.name for t in expected_type]}, got '{tok.type.name}'", line=tok.line, type="SyntaxError")
        error.display("Parsing")

    def search_blocks(self, id: str) -> bool:
        i = -1
        while -i <= len(self.table_stack):
            symbol = self.table_stack[i]
            if id in symbol.table:
                return True
            else:
                i -= 1
        return False
    
    # Builds AST from the program node down
    def parse_program(self) -> Program:
        functions = []
        while self.pos < len(self.tokens):
            func = self.parse_function()
            functions.append(func)
        return Program(functions=functions)

    def parse_function(self) -> Function:
        return_type = self.consume(
            TokenType.INT, TokenType.FLOAT,
            TokenType.CHAR, TokenType.VOID
            )
        name = self.consume(TokenType.ID)
        self.consume(TokenType.OPEN_PARENTHESIS)
        args = []
        while self.peek().type in self.keywords:
            arg_name = None
            type = self.consume(
                TokenType.INT, TokenType.FLOAT,
                TokenType.CHAR, TokenType.VOID
                )
            if self.peek().type == TokenType.ID:
                arg_name = self.consume(TokenType.ID)
            args.append((type.type, arg_name.value) if arg_name else (type.type, None))
            if self.peek().type == TokenType.COMMA:
                self.consume()
                if self.peek().type not in self.keywords:
                    error.report(error_msg=f"Misplaced comma in function {name.value}", line=name.line, type="SyntaxError")

        if not args: args.append((TokenType.VOID, None))
        symbol = SymbolTable(fun_name=name.value, args=args, return_type=return_type.type)
        self.consume(TokenType.CLOSE_PARENTHESIS)

        block = self.parse_block(symbol)
        return Function(
            name=name.value, variables=args,
            _return=return_type.type, body=block
            )

    def parse_block(self, func_table: SymbolTable = None) -> BlockItem:
        if not func_table:
            func_table = SymbolTable()
        self.table_stack.append(func_table)
        blk_itms = []
        self.consume(TokenType.OPEN_BRACE)
        while self.peek().type != TokenType.CLOSE_BRACE:
            if self.peek().type in self.keywords:
                blk_itms.append(self.parse_declare())
            elif self.peek().type == TokenType.OPEN_BRACE:
                blk_itms.append(self.parse_block())
            else:
                blk_itms.append(self.parse_statement())

        self.consume(TokenType.CLOSE_BRACE)
        self.table_stack.pop()
        return Block(block_items=blk_itms, symboltable=func_table)
        

    def parse_statement(self) -> Statement:
        if self.peek().type == TokenType.RETURN:
            ret = self.parse_return()
            self.consume(TokenType.SEMICOLON)
            return ret
        elif self.peek().type == TokenType.IF:
            return self.parse_if()
        elif self.peek().type == TokenType.FOR:
            return self.parse_for()
        elif self.peek().type == TokenType.WHILE:
            return self.parse_while()
        elif self.peek().type == TokenType.DO:
            return self.parse_do_while()
        elif self.peek().type == TokenType.BREAK:
            br = self.consume(TokenType.BREAK)
            self.consume(TokenType.SEMICOLON)
            return Break(line=br.line)
        elif self.peek().type == TokenType.CONTINUE:
            cn = self.consume(TokenType.CONTINUE)
            self.consume(TokenType.SEMICOLON)
            return Continue(line=cn.line)
        else:
            exp = self.parse_exp_statement()
            self.consume(TokenType.SEMICOLON)
            return exp
        

    # TODO: add in compatibility for calling functions

    def parse_declare(self) -> Declare:
        symbol = self.table_stack[-1]
        type = self.consume(
                TokenType.INT, TokenType.FLOAT,
                TokenType.CHAR, TokenType.VOID
                )
        id = self.consume(TokenType.ID)
        if id.value in symbol.table:
            error.report(
                error_msg=f"Cannot declare variable of same name {id.value} again in same scope",
                line=id.line, type="SyntaxError"
            )
        val = None
        next = self.peek()
        if next.type == TokenType.ASSIGNMENT:
            self.consume(TokenType.ASSIGNMENT)
            val = self.parse_assignment()
        entry = SymbolEntry(id=id.value, type=type.type, initialised=True, line=val.line)
        variable = Var(id=id.value, type=type.type, line=id.line)
        symbol.insert(id.value, entry)
        self.consume(TokenType.SEMICOLON)
        return Declare(id=variable, type=type.type, exp=val, line=id.line)

    def parse_return(self) -> Statement:
        ret = self.consume(TokenType.RETURN)
        if self.peek().type == TokenType.SEMICOLON:
            return Return(line=ret.line)
        else:
            exp = self.parse_assignment()
            return Return(exp=exp, line=ret.line)
        
    def parse_if(self):
        self.consume(TokenType.IF)
        self.consume(TokenType.OPEN_PARENTHESIS)
        cond = self.parse_assignment()
        self.consume(TokenType.CLOSE_PARENTHESIS)
        if self.peek().type == TokenType.OPEN_BRACE:
            if_stm = self.parse_block()
        else:
            if_stm = self.parse_statement()
        
        if self.peek().type != TokenType.ELSE:
            return If(condition=cond, if_statement=if_stm)
        self.consume(TokenType.ELSE)
        if self.peek().type == TokenType.IF:
            else_stm = self.parse_if()
        elif self.peek().type == TokenType.OPEN_BRACE:
            else_stm = self.parse_block()
        else:
            else_stm = self.parse_statement()
        return If(condition=cond, if_statement=if_stm, else_statement=else_stm)
    
    def parse_for(self) -> Statement:
        self.consume(TokenType.FOR)
        self.consume(TokenType.OPEN_PARENTHESIS)
        symbol = None
        if self.peek().type == TokenType.INT:
            symbol = SymbolTable()
            self.table_stack.append(symbol)
            init = self.parse_declare()
        else:
            init = self.parse_exp_statement()
        self.consume(TokenType.SEMICOLON)
        control = self.parse_exp_statement()
        if not control.exp:
            control = ExpStatement(line=control.line, exp=IntLiteral(value=1, line=control.line))
        self.consume(TokenType.SEMICOLON)
        post_exp = self.parse_exp_statement()
        if self.peek().type == TokenType.CLOSE_PARENTHESIS:
            self.consume(TokenType.CLOSE_PARENTHESIS)
        stm = self.parse_block()
        if isinstance(init, Declare):
            self.table_stack.pop()
        return For(initial=init, condition=control, post_exp=post_exp, statement=stm, symboltable=(symbol if symbol else None))

    def parse_while(self) -> Statement:
        self.consume(TokenType.WHILE)
        self.consume(TokenType.OPEN_PARENTHESIS)
        control = self.parse_exp_statement()
        if not control.exp:
            control = ExpStatement(exp=IntLiteral(value=1, line=control.line))
        else:
            self.consume(TokenType.CLOSE_PARENTHESIS)
        stm = self.parse_block()
        return While(condition=control, statement=stm)

    def parse_do_while(self) -> Statement:
        self.consume(TokenType.DO)
        stm = self.parse_block()
        self.consume(TokenType.WHILE)
        self.consume(TokenType.OPEN_PARENTHESIS)
        control = self.parse_exp_statement()
        if not control.exp:
            control = ExpStatement(exp=IntLiteral(value=1, line=control.line))
        else:
            self.consume(TokenType.CLOSE_PARENTHESIS)
        return DoWhile(statement=stm, condition=control)
        
    def parse_exp_statement(self) -> Statement:
        if self.peek().type == TokenType.SEMICOLON:
            null_stm = self.consume(TokenType.SEMICOLON)
            return ExpStatement(line=null_stm.line)
        elif self.peek().type == TokenType.CLOSE_PARENTHESIS:
            null_stm = self.consume(TokenType.CLOSE_PARENTHESIS)
            return ExpStatement(line=null_stm.line)
        else:
            exp = self.parse_assignment()
            return ExpStatement(line=exp.line, exp=exp)
    
    def parse_comma_exp(self) -> Exp:
        exp = self.parse_assignment()
        while self.peek().type == TokenType.COMMA:
            self.consume(TokenType.COMMA)
            rhs_exp = self.parse_assignment()
            exp = CommaExp(lhs=exp, rhs=rhs_exp, line=exp.line)       
        return exp

    def parse_assignment(self) -> Exp:
        if self.peek().type != TokenType.ID:
            return self.parse_conditional()
        
        self.pos += 1
        if self.peek().type not in (
            TokenType.ASSIGNMENT, TokenType.ASSIGN_ADD, TokenType.ASSIGN_SUB, 
            TokenType.ASSIGN_MULT, TokenType.ASSIGN_DIV, TokenType.ASSIGN_MOD,
            TokenType.ASSIGN_BIT_AND, TokenType.ASSIGN_BIT_OR, TokenType.ASSIGN_BIT_XOR,
            TokenType.ASSIGN_LEFT_SHIFT, TokenType.ASSIGN_RIGHT_SHIFT
            ):
            self.pos -= 1
            return self.parse_conditional()
        self.pos -= 1
        var = self.consume(TokenType.ID)

        if self.search_blocks(var.value) == None:
            error.report(error_msg=f"Cannot assign a value to undeclared variable {var.value}", line=var.line, type="SyntaxError")
        
        symbol = self.table_stack[-1]
        if self.peek().type != TokenType.ASSIGNMENT and not symbol.get(var.value).initialised:
            error.report(
                error_msg=f"Cannot perform operation {self.peek().type.name} on uninitialised variable {var.value}",
                line=var.line, type="SyntaxError"
                )

        operation = self.consume(
            TokenType.ASSIGNMENT, TokenType.ASSIGN_ADD, TokenType.ASSIGN_SUB, 
            TokenType.ASSIGN_MULT, TokenType.ASSIGN_DIV, TokenType.ASSIGN_MOD,
            TokenType.ASSIGN_BIT_AND, TokenType.ASSIGN_BIT_OR, TokenType.ASSIGN_BIT_XOR,
            TokenType.ASSIGN_LEFT_SHIFT, TokenType.ASSIGN_RIGHT_SHIFT
            )
        if self.peek().type == TokenType.ID:
            assign = self.parse_assignment()
            if isinstance(assign, Assign):
                assign = assign.id  # Assign.id is a Var
        else:
            assign = self.parse_conditional()

        variable = Var(id=var.value, line=var.line)

        if operation.type == TokenType.ASSIGN_ADD:
            assign = AddSub(operator=TokenType.ADDITION, operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_SUB:
            assign = AddSub(operator=TokenType.SUBTRACTION, operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_MULT:
            assign = MultDivMod(operator=TokenType.MULTIPLICATION, operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_DIV:
            assign = MultDivMod(operator=TokenType.DIVISION, operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_MOD:
            assign = MultDivMod(operator=TokenType.MODULO, operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_BIT_AND:
            assign = BitAND(operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_BIT_OR:
            assign = BitOR(operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_BIT_OR:
            assigne = BitXOR(operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_RIGHT_SHIFT:
            assign = BitShift(operator=TokenType.BIT_SHIFT_RIGHT, operand1=variable, operand2=assign, line=var.line)
        elif operation.type == TokenType.ASSIGN_LEFT_SHIFT:
            assign = BitShift(operator=TokenType.BIT_SHIFT_LEFT, operand1=variable, operand2=assign, line=var.line)

        return Assign(id=variable, exp=assign, line=var.line)

    def parse_conditional(self) -> Exp:
        cond = self.parse_or()
        if self.peek().type != TokenType.QUESTION_MARK:
            return cond
        self.consume(TokenType.QUESTION_MARK)
        if_stm = self.parse_assignment()
        self.consume(TokenType.COLON)
        else_stm = self.parse_conditional()
        return Conditional(condition=cond, if_statement=if_stm, else_statement=else_stm, line=cond.line)

    def parse_or(self) -> Exp:
        exp = self.parse_and()
        while self.peek().type == TokenType.OR:
            self.pos += 1
            next_exp = self.parse_and()
            exp = OR(operand1=exp, operand2=next_exp, line=exp.line)
        return exp
    
    def parse_and(self) -> Exp:
        exp = self.parse_equality()
        while self.peek().type == TokenType.AND:
            self.pos += 1
            next_exp = self.parse_equality()
            exp = AND(operand1=exp, operand2=next_exp, line=exp.line)
        return exp

    def parse_equality(self) -> Exp:
        exp = self.parse_inequality()
        while self.peek().type == TokenType.EQUAL or self.peek().type == TokenType.NOT_EQUAL:
            op = self.consume(TokenType.EQUAL, TokenType.NOT_EQUAL)
            next_exp = self.parse_inequality()
            exp = Equality(operator=op.type, operand1=exp, operand2=next_exp, line=exp.line)
        return exp

    def parse_inequality(self) -> Exp:
        exp = self.parse_bit_or()
        while (self.peek().type == TokenType.LESS_THAN or self.peek().type == TokenType.LESS_THAN_OR_EQUAL
        or self.peek().type == TokenType.GREATER_THAN or self.peek().type == TokenType.GREATER_THAN_OR_EQUAL):
            op = self.consume(
                TokenType.LESS_THAN, TokenType.LESS_THAN_OR_EQUAL,
                TokenType.GREATER_THAN, TokenType.GREATER_THAN_OR_EQUAL
                )
            next_exp = self.parse_bit_or()
            exp = Inequality(operator=op.type, operand1=exp, operand2=next_exp, line=exp.line)
        return exp

    def parse_bit_or(self) -> Exp:
        exp = self.parse_bit_xor()
        while self.peek().type == TokenType.BIT_OR:
            self.pos += 1
            next_exp = self.parse_bit_xor()
            exp = BitOR(operand1=exp, operand2=next_exp, line=exp.line)
        return exp

    def parse_bit_xor(self) -> Exp:
        exp = self.parse_bit_and()
        while self.peek().type == TokenType.BIT_XOR:
            self.pos += 1
            next_exp = self.parse_bit_and()
            exp = BitXOR(operand1=exp, operand2=next_exp, line=exp.line)
        return exp
    
    def parse_bit_and(self) -> Exp:
        exp = self.parse_bit_shift()
        while self.peek().type == TokenType.BIT_AND:
            self.pos += 1
            next_exp = self.parse_bit_shift()
            exp = BitAND(operand1=exp, operand2=next_exp, line=exp.line)
        return exp

    def parse_bit_shift(self) -> Exp:
        exp = self.parse_addsub()
        while self.peek().type == TokenType.BIT_SHIFT_LEFT or self.peek().type == TokenType.BIT_SHIFT_RIGHT:
            op = self.consume(TokenType.BIT_SHIFT_LEFT, TokenType.BIT_SHIFT_RIGHT)
            shift_amount = self.parse_addsub()
            exp = BitShift(operator=op.type, value=exp, shift=shift_amount, line=exp.line)
        return exp

    def parse_addsub(self) -> Exp:
        term = self.parse_term()
        while self.peek().type == TokenType.ADDITION or self.peek().type == TokenType.SUBTRACTION:
            op = self.consume(TokenType.ADDITION, TokenType.SUBTRACTION)
            next_term = self.parse_term()
            term = AddSub(operator=op.type, operand1=term, operand2=next_term, line=term.line)
        return term
    
    def parse_term(self) -> Exp:
        fact = self.parse_fact()
        while (
            self.peek().type == TokenType.MULTIPLICATION
            or self.peek().type == TokenType.DIVISION
            or self.peek().type == TokenType.MODULO
            ):
            op = self.consume(TokenType.MULTIPLICATION, TokenType.DIVISION, TokenType.MODULO)
            next_fact = self.parse_fact()
            fact = MultDivMod(operator=op.type, operand1=fact, operand2=next_fact, line=fact.line)
        return fact
    

    def parse_fact(self) -> Exp:
        tok = self.consume(
            TokenType.OPEN_PARENTHESIS,
            TokenType.INT_LITERAL,
            TokenType.SUBTRACTION, 
            TokenType.BIT_COMP, 
            TokenType.LOGICAL_NEGATION,
            TokenType.ID, 
            TokenType.INCREMENT,
            TokenType.DECREMENT
        )
        if tok.type == TokenType.OPEN_PARENTHESIS:
            tok = self.parse_comma_exp()
            self.consume(TokenType.CLOSE_PARENTHESIS)
            return Parenthesis(exp=tok, line=tok.line)
        
        elif tok.type == TokenType.INT_LITERAL:
            return IntLiteral(value=int(tok.value), line=tok.line)
        
        elif (
            tok.type == TokenType.BIT_COMP or tok.type == TokenType.SUBTRACTION 
            or tok.type == TokenType.LOGICAL_NEGATION 
        ):
            inner_exp = self.parse_fact()
            return UnOp(operator=tok.type, operand=inner_exp, line=tok.line)

        elif tok.type == TokenType.INCREMENT or tok.type == TokenType.DECREMENT:
            id = self.consume(TokenType.ID)
            symbol = self.table_stack[-1]
            if tok.value not in symbol.table:
                error.report(error_msg=f"Variable {tok.value} not declared at this scope", line=tok.line, type="SyntaxError")

            if tok.type == TokenType.INCREMENT:
                return Increment(id=id.value, prefix=True, line=tok.line)
            elif tok.type == TokenType.DECREMENT:
                return Decrement(id=id.value, prefix=True, line=tok.line)

        
        elif tok.type == TokenType.ID:
            symbol = self.table_stack[-1]
            if self.search_blocks(tok.value) == False:
                error.report(error_msg=f"Variable {tok.value} not declared at this scope", line=tok.line, type="SyntaxError")

            if self.peek().type == TokenType.OPEN_PARENTHESIS:
                self.consume(TokenType.OPEN_PARENTHESIS)
                params = []
                while self.peek().type == TokenType.ID:
                    arg = self.consume(TokenType.ID)
                    params.append(arg)
                    if self.peek().type == TokenType.COMMA:
                        self.consume(TokenType.COMMA)
                return FunctionCall(name=tok.value, param=params)

            elif self.peek().type == TokenType.INCREMENT:
                self.consume(TokenType.INCREMENT)
                return Increment(id=tok.value, prefix=False, line=tok.line)
            elif self.peek().type == TokenType.DECREMENT:
                self.consume(TokenType.DECREMENT)
                return Decrement(id=tok.value, prefix=False, line=tok.line)
                
            else:
                return Var(id=tok.value, line=tok.line)